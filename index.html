<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>INABRA-kadrabra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #1a2f1a;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: linear-gradient(to bottom, #2d5a27, #1e3c1b);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #4a9c42;
            border-radius: 8px;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .hud-text {
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        .btn {
            background: #e67e22;
            border: 4px solid #d35400;
            color: white;
            padding: 20px 40px;
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s;
            touch-action: manipulation;
            z-index: 40;
            pointer-events: auto;
        }
        
        .btn:hover {
            transform: scale(1.05);
            background: #f39c12;
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* Indicateur de destination (petit cercle l√† o√π on touche) */
        #touch-marker {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="touch-marker"></div>

    <!-- UI (Vies, Score, Niveau) -->
    <div id="ui-layer">
        <div class="hud-text text-xl text-yellow-400">INABRA-kadrabra</div>
        <div class="hud-text" id="level-display">Niveau: 1</div>
        <div class="hud-text" id="score-display">Score: 0</div>
        <div id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="boss-hp-container" class="hidden mt-4 w-64 bg-gray-800 border-2 border-white h-6 relative">
            <div id="boss-hp-bar" class="bg-red-600 h-full w-full transition-all duration-200"></div>
            <span class="absolute top-0 left-0 w-full text-center text-xs leading-5 shadow-black drop-shadow-md">BOSS</span>
        </div>
        <div class="hud-text text-xs text-gray-300 mt-2 opacity-70">
            PC: Souris + Espace<br>
            Mobile: Touche l'√©cran pour bouger
        </div>
    </div>

    <!-- Ecrans de Menu / Game Over -->
    <div id="overlay">
        <h1 class="text-3xl md:text-4xl text-green-400 mb-4 tracking-widest text-shadow px-4">INABRA-KADRABRA</h1>
        <p class="text-gray-300 mb-8 max-w-md leading-6 text-sm px-4">
            Survivre dans la jungle maudite.<br><br>
            <span class="text-yellow-300">AUDIO ACTIV√â üîä</span><br>
            <span class="text-green-300">NOUVEAU CONTR√îLE :</span><br>
            Le magicien court vers ton doigt !<br>
            Tape avec un 2√®me doigt pour TIRER.
        </p>
        <button class="btn" id="start-btn">JOUER</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const touchMarker = document.getElementById('touch-marker');
    
    // --- Configuration du Jeu ---
    let width, height;
    
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // √âtat du jeu
    const state = {
        isRunning: false,
        isGameOver: false,
        level: 1,
        score: 0,
        enemiesKilledInLevel: 0,
        frames: 0,
        bossActive: false
    };

    const levels = {
        1: { killsToBoss: 10, spawnRate: 100, enemySpeed: 1.5, bossHp: 50, color: "#2d5a27", bossName: "Grand Serpent" },
        2: { killsToBoss: 15, spawnRate: 80, enemySpeed: 2.2, bossHp: 100, color: "#1e3c1b", bossName: "Roi Gorille" },
        3: { killsToBoss: 20, spawnRate: 60, enemySpeed: 3.0, bossHp: 200, color: "#2c1e3c", bossName: "Sorcier Maudit" }
    };

    // --- SYSTEME AUDIO (Synth√©tiseur WebAudio) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const sfx = {
        shoot: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        },
        hit: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        },
        damage: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        },
        powerup: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }
    };

    let musicInterval;
    function startMusic() {
        if (musicInterval) clearInterval(musicInterval);
        let beat = 0;
        musicInterval = setInterval(() => {
            if (!state.isRunning) return;
            const t = audioCtx.currentTime;
            
            // Drum Kick (sur les temps 1 et 3)
            if (beat % 4 === 0) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(t);
                osc.stop(t + 0.5);
            }
            
            // Snare/Hat (sur les autres temps, plus rapide)
            if (beat % 2 === 0 && beat % 4 !== 0) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle'; // Un peu noise
                osc.frequency.setValueAtTime(100, t); // Bruit blanc simul√© malproprement mais √ßa marche pour du retro
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            }

            // Bassline (Tribal simple)
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(100 + (beat % 3)*20, t);
            gain.gain.setValueAtTime(0.05, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.1);

            beat++;
        }, 250); // 120 BPM approx
    }

    // --- CONTROLES (SUIVI DOIGT) ---
    const input = {
        targetX: null,
        targetY: null,
        isFollowing: false,
        shooting: false
    };

    // Gestion Touch
    window.addEventListener('touchstart', e => {
        if (!state.isRunning) return;
        e.preventDefault();

        for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            
            // Le premier doigt d√©finit la cible de mouvement
            if (i === 0) {
                input.isFollowing = true;
                input.targetX = touch.clientX;
                input.targetY = touch.clientY;
                
                touchMarker.style.display = 'block';
                touchMarker.style.left = touch.clientX + 'px';
                touchMarker.style.top = touch.clientY + 'px';
            }
            // Tout doigt suppl√©mentaire (index > 0) d√©clenche le tir
            else {
                input.shooting = true;
            }
        }
    }, { passive: false });

    window.addEventListener('touchmove', e => {
        if (!state.isRunning) return;
        e.preventDefault();

        // Mettre √† jour la cible avec le premier doigt
        if (e.touches.length > 0) {
            const touch = e.touches[0];
            input.targetX = touch.clientX;
            input.targetY = touch.clientY;
            
            touchMarker.style.left = touch.clientX + 'px';
            touchMarker.style.top = touch.clientY + 'px';
        }
    }, { passive: false });

    window.addEventListener('touchend', e => {
        if (!state.isRunning) return;
        e.preventDefault();
        
        // Si on rel√®ve le premier doigt (plus de doigts ou seulement le 2eme reste)
        // On arr√™te de suivre si on n'a plus de doigts du tout
        if (e.touches.length === 0) {
            input.isFollowing = false;
            input.shooting = false;
            touchMarker.style.display = 'none';
        } 
        // Si il reste des doigts, on v√©rifie si c'√©tait le doigt de tir
        else {
             // Simplification : si on touche encore, on bouge, mais on coupe le tir
             input.shooting = false;
        }
    });

    // Gestion PC (Souris)
    window.addEventListener('mousedown', e => {
        if (!state.isRunning) return;
        if (!('ontouchstart' in window)) {
            input.isFollowing = true;
            input.targetX = e.clientX;
            input.targetY = e.clientY;
            touchMarker.style.display = 'block';
            touchMarker.style.left = e.clientX + 'px';
            touchMarker.style.top = e.clientY + 'px';
        }
    });

    window.addEventListener('mousemove', e => {
        if (!state.isRunning) return;
        if (input.isFollowing && !('ontouchstart' in window)) {
            input.targetX = e.clientX;
            input.targetY = e.clientY;
            touchMarker.style.left = e.clientX + 'px';
            touchMarker.style.top = e.clientY + 'px';
        }
    });

    window.addEventListener('mouseup', () => {
        if (!('ontouchstart' in window)) {
            input.isFollowing = false;
            touchMarker.style.display = 'none';
        }
    });

    window.addEventListener('keydown', e => {
        if (e.code === 'Space') input.shooting = true;
    });
    window.addEventListener('keyup', e => {
        if (e.code === 'Space') input.shooting = false;
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        // Init Audio Context on user gesture
        if (audioCtx.state === 'suspended') audioCtx.resume();
        startGame();
    });

    // --- CLASSES JEU ---
    let player, projectiles, enemies, particles, powerups, boss;

    class Player {
        constructor() {
            this.x = width / 2;
            this.y = height / 2;
            this.size = 40;
            this.speed = 5;
            this.lives = 5;
            this.maxLives = 5;
            this.fireRate = 25;
            this.lastShot = 0;
            this.spreadShot = false;
            this.speedBoost = false;
        }

        update() {
            // Mouvement vers la cible (Doigt)
            if (input.isFollowing && input.targetX !== null) {
                const dx = input.targetX - this.x;
                const dy = input.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                
                let currentSpeed = this.speedBoost ? this.speed * 1.5 : this.speed;

                if (dist > 10) { // Zone morte pour √©viter le tremblement
                    this.x += (dx / dist) * currentSpeed;
                    this.y += (dy / dist) * currentSpeed;
                }
            }

            // Limites √©cran
            this.x = Math.max(this.size, Math.min(width - this.size, this.x));
            this.y = Math.max(this.size, Math.min(height - this.size, this.y));
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.speedBoost) {
                ctx.beginPath();
                ctx.arc(0, 0, this.size/1.5, 0, Math.PI * 2);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Flip si on va √† gauche
            if (input.targetX < this.x) ctx.scale(-1, 1);
            ctx.fillText('üßô‚Äç‚ôÇÔ∏è', 0, 0);
            ctx.restore();
        }

        shoot() {
            if (state.frames - this.lastShot < this.fireRate) return;
            
            sfx.shoot(); // Bruitage

            let target = null;
            let minDist = Infinity;
            if (state.bossActive && boss) {
                const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                target = boss;
                minDist = dist;
            }
            enemies.forEach(e => {
                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist < minDist) {
                    minDist = dist;
                    target = e;
                }
            });
            let angle;
            if (target) {
                angle = Math.atan2(target.y - this.y, target.x - this.x);
            } else {
                angle = -Math.PI / 2; // Haut par d√©faut
                // Tirer vers le mouvement si on bouge
                if (input.isFollowing) {
                    angle = Math.atan2(input.targetY - this.y, input.targetX - this.x);
                }
            }
            
            projectiles.push(new Projectile(this.x, this.y, angle));
            if (this.spreadShot) {
                projectiles.push(new Projectile(this.x, this.y, angle - 0.3));
                projectiles.push(new Projectile(this.x, this.y, angle + 0.3));
            }
            this.lastShot = state.frames;
            createParticles(this.x, this.y, '#3498db', 3);
        }

        takeDamage() {
            this.lives--;
            sfx.damage();
            updateHUD();
            screenShake(10);
            createParticles(this.x, this.y, '#e74c3c', 10);
            if (this.lives <= 0) endGame();
        }
    }

    class Projectile {
        constructor(x, y, angle, isEnemy = false) {
            this.x = x;
            this.y = y;
            this.radius = isEnemy ? 6 : 4;
            this.speed = isEnemy ? 6 : 10;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.color = isEnemy ? '#e74c3c' : '#f1c40f';
            this.isEnemy = isEnemy;
            this.markedForDeletion = false;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.markedForDeletion = true;
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.speed = levels[state.level].enemySpeed + (Math.random() * 0.5);
            this.hp = state.level;
            this.markedForDeletion = false;
            const types = ['üêç', 'üï∑Ô∏è', 'ü¶á'];
            this.emoji = types[(state.level - 1) % types.length];
        }
        update() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
        }
        draw() {
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x, this.y);
        }
    }

    class Boss {
        constructor() {
            this.x = width / 2;
            this.y = -100;
            this.targetY = 100;
            this.size = 80;
            this.maxHp = levels[state.level].bossHp;
            this.hp = this.maxHp;
            this.angle = 0;
            this.actionTimer = 0;
            const bosses = ['üêâ', 'ü¶ç', 'üë∫'];
            this.emoji = bosses[state.level - 1];
        }
        update() {
            if (this.y < this.targetY) { this.y += 2; return; }
            this.x += Math.sin(state.frames / 50) * 3;
            this.actionTimer++;
            if (this.actionTimer > 60) {
                this.attack();
                this.actionTimer = 0;
            }
        }
        attack() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            sfx.shoot(); // Bruitage boss
            if (state.level === 1) {
                projectiles.push(new Projectile(this.x, this.y, angle, true));
            } else if (state.level === 2) {
                projectiles.push(new Projectile(this.x, this.y, angle, true));
                projectiles.push(new Projectile(this.x, this.y, angle - 0.3, true));
                projectiles.push(new Projectile(this.x, this.y, angle + 0.3, true));
            } else {
                for(let i=0; i<8; i++) {
                    projectiles.push(new Projectile(this.x, this.y, angle + (i * Math.PI/4), true));
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            const scale = 1 + Math.sin(state.frames / 20) * 0.1;
            ctx.scale(scale, scale);
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, 0, 0);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 20;
            this.markedForDeletion = false;
            const types = [
                { type: 'heal', emoji: '‚ù§Ô∏è', color: '#e74c3c' },
                { type: 'spread', emoji: '‚ö°', color: '#f1c40f' },
                { type: 'speed', emoji: 'üëü', color: '#3498db' }
            ];
            let rand = Math.random();
            if (player.lives <= 2 && rand < 0.5) {
                this.props = types[0];
            } else {
                this.props = types[Math.floor(Math.random() * types.length)];
            }
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y + Math.sin(state.frames/10)*5, 15, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.props.emoji, this.x, this.y + Math.sin(state.frames/10)*5);
        }
    }

    class Particle {
        constructor(x, y, color, speed) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 3 + 1;
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * speed;
            this.vx = Math.cos(angle) * velocity;
            this.vy = Math.sin(angle) * velocity;
            this.life = 1.0;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.02;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color, 2));
        }
    }

    function spawnEnemy() {
        if (state.bossActive) return;
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -30 : width + 30;
            y = Math.random() * height;
        } else {
            x = Math.random() * width;
            y = Math.random() < 0.5 ? -30 : height + 30;
        }
        enemies.push(new Enemy(x, y));
    }

    function checkCollisions() {
        projectiles.forEach(p => {
            if (p.isEnemy) return;
            if (state.bossActive && boss) {
                const dist = Math.hypot(p.x - boss.x, p.y - boss.y);
                if (dist < boss.size/2 + p.radius) {
                    boss.hp -= 5;
                    p.markedForDeletion = true;
                    sfx.hit();
                    createParticles(p.x, p.y, '#fff', 5);
                    const percent = (boss.hp / boss.maxHp) * 100;
                    document.getElementById('boss-hp-bar').style.width = `${percent}%`;
                    if (boss.hp <= 0) levelComplete();
                }
            }
            enemies.forEach(e => {
                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if (dist < e.size/2 + p.radius) {
                    e.hp--;
                    p.markedForDeletion = true;
                    if (e.hp <= 0) {
                        e.markedForDeletion = true;
                        state.score += 10;
                        state.enemiesKilledInLevel++;
                        sfx.hit();
                        createParticles(e.x, e.y, '#2ecc71', 8);
                        if (Math.random() < 0.15) powerups.push(new PowerUp(e.x, e.y));
                        updateHUD();
                    } else {
                        createParticles(e.x, e.y, '#fff', 2);
                    }
                }
            });
        });

        enemies.forEach(e => {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < player.size/2 + e.size/2) {
                player.takeDamage();
                e.markedForDeletion = true;
            }
        });

        projectiles.forEach(p => {
            if (!p.isEnemy) return;
            const dist = Math.hypot(p.x - player.x, p.y - player.y);
            if (dist < player.size/2 + p.radius) {
                player.takeDamage();
                p.markedForDeletion = true;
            }
        });

        powerups.forEach(p => {
            const dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size/2 + p.size) {
                applyPowerUp(p.props.type);
                p.markedForDeletion = true;
            }
        });
    }

    function applyPowerUp(type) {
        sfx.powerup();
        const text = document.createElement('div');
        text.className = 'absolute text-yellow-300 font-bold text-xl animate-bounce';
        text.style.left = player.x + 'px';
        text.style.top = (player.y - 40) + 'px';
        text.innerText = type.toUpperCase() + "!";
        document.body.appendChild(text);
        setTimeout(() => text.remove(), 1000);

        if (type === 'heal') {
            player.lives = Math.min(player.lives + 1, player.maxLives);
            updateHUD();
        } else if (type === 'spread') {
            player.spreadShot = true;
            setTimeout(() => player.spreadShot = false, 8000);
        } else if (type === 'speed') {
            player.speedBoost = true;
            setTimeout(() => player.speedBoost = false, 8000);
        }
    }

    function checkLevelProgress() {
        if (!state.bossActive && state.enemiesKilledInLevel >= levels[state.level].killsToBoss) {
            spawnBoss();
        }
    }

    function spawnBoss() {
        state.bossActive = true;
        boss = new Boss();
        const bossContainer = document.getElementById('boss-hp-container');
        bossContainer.classList.remove('hidden');
        document.getElementById('boss-hp-bar').style.width = '100%';
        const alert = document.createElement('div');
        alert.innerText = "ATTENTION: " + levels[state.level].bossName + " !";
        alert.className = "absolute top-1/3 w-full text-center text-red-500 text-3xl font-bold blink";
        document.body.appendChild(alert);
        setTimeout(() => alert.remove(), 3000);
    }

    function levelComplete() {
        if (state.level >= 3) {
            winGame();
        } else {
            state.level++;
            state.enemiesKilledInLevel = 0;
            state.bossActive = false;
            boss = null;
            document.getElementById('boss-hp-container').classList.add('hidden');
            player.lives = 5;
            updateHUD();
            showOverlay(`
                <h2 class="text-3xl text-yellow-400 mb-4">Niveau Termin√© !</h2>
                <p>Pr√™t pour le niveau ${state.level} ?</p>
                <button class="btn" onclick="resumeGame()">Continuer</button>
            `);
            state.isRunning = false;
        }
    }

    let shakeDuration = 0;
    function screenShake(frames) {
        shakeDuration = frames;
    }

    function loop() {
        if (!state.isRunning) return;
        ctx.fillStyle = levels[state.level].color;
        ctx.fillRect(0, 0, width, height);

        if (shakeDuration > 0) {
            const dx = (Math.random() - 0.5) * 10;
            const dy = (Math.random() - 0.5) * 10;
            ctx.translate(dx, dy);
            shakeDuration--;
        }

        state.frames++;
        player.update();
        player.draw();
        
        // Auto-shoot si demand√© via touch ou space
        if (input.shooting) player.shoot();
        
        if (!state.bossActive && state.frames % levels[state.level].spawnRate === 0) spawnEnemy();
        
        enemies.forEach((e, i) => { e.update(); e.draw(); if (e.markedForDeletion) enemies.splice(i, 1); });
        if (state.bossActive && boss) { boss.update(); boss.draw(); }
        projectiles.forEach((p, i) => { p.update(); p.draw(); if (p.markedForDeletion) projectiles.splice(i, 1); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });
        powerups.forEach((p, i) => { p.draw(); if (p.markedForDeletion) powerups.splice(i, 1); });

        checkCollisions();
        checkLevelProgress();

        if (shakeDuration >= 0) ctx.setTransform(1, 0, 0, 1, 0, 0); 
        requestAnimationFrame(loop);
    }

    function updateHUD() {
        document.getElementById('level-display').innerText = `Niveau: ${state.level}`;
        document.getElementById('score-display').innerText = `Score: ${state.score}`;
        let hearts = '';
        for(let i=0; i<player.lives; i++) hearts += '‚ù§Ô∏è';
        document.getElementById('lives-display').innerHTML = hearts;
    }

    function showOverlay(htmlContent) {
        const overlay = document.getElementById('overlay');
        overlay.classList.remove('hidden');
        overlay.innerHTML = htmlContent;
    }

    function startGame() {
        document.getElementById('overlay').classList.add('hidden');
        
        player = new Player();
        enemies = [];
        projectiles = [];
        particles = [];
        powerups = [];
        boss = null;
        
        state.level = 1;
        state.score = 0;
        state.enemiesKilledInLevel = 0;
        state.lives = 5;
        state.isRunning = true;
        state.bossActive = false;
        
        input.isFollowing = false;
        input.targetX = null;
        input.targetY = null;
        input.shooting = false;
        
        updateHUD();
        document.getElementById('boss-hp-container').classList.add('hidden');
        
        startMusic();
        loop();
    }

    window.resumeGame = function() {
        document.getElementById('overlay').classList.add('hidden');
        state.isRunning = true;
        projectiles = [];
        loop();
    };

    window.startGame = startGame;

    function endGame() {
        state.isRunning = false;
        clearInterval(musicInterval);
        showOverlay(`
            <h1 class="text-red-500 text-4xl mb-4">GAME OVER</h1>
            <p class="text-xl mb-4">Score Final: ${state.score}</p>
            <button class="btn" onclick="startGame()">Recommencer</button>
        `);
    }

    function winGame() {
        state.isRunning = false;
        clearInterval(musicInterval);
        showOverlay(`
            <h1 class="text-yellow-400 text-4xl mb-4">VICTOIRE !</h1>
            <p class="mb-4">Tu as surv√©cu √† la jungle INABRA-KADRABRA !</p>
            <p class="text-xl mb-4">Score Final: ${state.score}</p>
            <button class="btn" onclick="startGame()">Rejouer</button>
        `);
    }

</script>
</body>
</html>
