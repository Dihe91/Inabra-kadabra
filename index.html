<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>INABRA-kadrabra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #1a2f1a;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
            touch-action: none; /* Crucial pour mobile */
            -webkit-touch-callout: none; /* iOS Safari */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: linear-gradient(to bottom, #2d5a27, #1e3c1b);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #4a9c42;
            border-radius: 8px;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .hud-text {
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30; /* Augment√© pour √™tre s√ªr d'√™tre au dessus */
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        .btn {
            background: #e67e22;
            border: 4px solid #d35400;
            color: white;
            padding: 20px 40px; /* Plus gros pour le tactile */
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s;
            touch-action: manipulation; /* Aide pour le clic mobile */
            z-index: 40;
            pointer-events: auto; /* S'assure que le bouton re√ßoit les clics */
        }
        
        .btn:hover {
            transform: scale(1.05);
            background: #f39c12;
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* Indicateur de Joystick Virtuel */
        #joystick-zone {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        #joystick-knob {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

    <!-- UI (Vies, Score, Niveau) -->
    <div id="ui-layer">
        <div class="hud-text text-xl text-yellow-400">INABRA-kadrabra</div>
        <div class="hud-text" id="level-display">Niveau: 1</div>
        <div class="hud-text" id="score-display">Score: 0</div>
        <div id="lives-display">
            ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è
        </div>
        <div id="boss-hp-container" class="hidden mt-4 w-64 bg-gray-800 border-2 border-white h-6 relative">
            <div id="boss-hp-bar" class="bg-red-600 h-full w-full transition-all duration-200"></div>
            <span class="absolute top-0 left-0 w-full text-center text-xs leading-5 shadow-black drop-shadow-md">BOSS</span>
        </div>
        <div class="hud-text text-xs text-gray-300 mt-2 opacity-70">
            PC: Souris + Espace<br>
            Mobile: Glisse + Tap
        </div>
    </div>

    <!-- Ecrans de Menu / Game Over -->
    <div id="overlay">
        <h1 class="text-3xl md:text-4xl text-green-400 mb-4 tracking-widest text-shadow px-4">INABRA-KADRABRA</h1>
        <p class="text-gray-300 mb-8 max-w-md leading-6 text-sm px-4">
            Survivre dans la jungle maudite.<br><br>
            <span class="text-yellow-300">COMMANDES MOBILE:</span><br>
            1. Pose un doigt et glisse pour BOUGER.<br>
            2. Tape avec un autre doigt pour TIRER.<br>
        </p>
        <button class="btn" id="start-btn">JOUER</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Configuration du Jeu ---
    let width, height;
    
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // √âtat du jeu
    const state = {
        isRunning: false,
        isGameOver: false,
        isPaused: false,
        level: 1,
        score: 0,
        enemiesKilledInLevel: 0,
        frames: 0,
        bossActive: false
    };

    // Configuration des Niveaux
    const levels = {
        1: { killsToBoss: 10, spawnRate: 100, enemySpeed: 1.5, bossHp: 50, color: "#2d5a27", bossName: "Grand Serpent" },
        2: { killsToBoss: 15, spawnRate: 80, enemySpeed: 2.2, bossHp: 100, color: "#1e3c1b", bossName: "Roi Gorille" },
        3: { killsToBoss: 20, spawnRate: 60, enemySpeed: 3.0, bossHp: 200, color: "#2c1e3c", bossName: "Sorcier Maudit" }
    };

    // Entit√©s
    let player;
    let projectiles = [];
    let enemies = [];
    let particles = [];
    let powerups = [];
    let boss = null;

    // --- CONTROLES (JOYSTICK & TOUCH) ---
    const input = {
        x: 0,
        y: 0,
        active: false,
        shooting: false,
        joystickOrigin: { x: 0, y: 0 }
    };

    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');

    // Gestion Touch (Mobile)
    // IMPORTANT: On attache les √©couteurs avec { passive: false } pour pouvoir utiliser preventDefault
    // Mais on ne bloque l'√©v√©nement que si le jeu est EN COURS pour laisser les boutons fonctionner.

    window.addEventListener('touchstart', e => {
        // Si le jeu n'est pas lanc√©, on laisse faire (pour pouvoir cliquer sur les boutons)
        if (!state.isRunning) return;

        // Si le jeu tourne, on emp√™che le scroll/zoom et on g√®re le joystick
        e.preventDefault();

        // Le premier doigt active le mouvement
        if (!input.active && e.touches.length > 0) {
            const touch = e.touches[0];
            input.active = true;
            input.joystickOrigin.x = touch.clientX;
            input.joystickOrigin.y = touch.clientY;
            
            // Afficher le joystick visuel
            joystickZone.style.display = 'block';
            joystickZone.style.left = touch.clientX + 'px';
            joystickZone.style.top = touch.clientY + 'px';
            joystickKnob.style.transform = `translate(-50%, -50%)`;
        }

        // Si plus d'un doigt, on tire
        if (e.touches.length > 1) {
            input.shooting = true;
        }
    }, { passive: false });

    window.addEventListener('touchmove', e => {
        if (!state.isRunning) return; // Laisser passer si menu
        e.preventDefault();

        if (input.active && e.touches.length > 0) {
            const touch = e.touches[0];
            const dx = touch.clientX - input.joystickOrigin.x;
            const dy = touch.clientY - input.joystickOrigin.y;
            
            const distance = Math.hypot(dx, dy);
            const maxDist = 50;
            
            const visualDist = Math.min(distance, maxDist);
            const angle = Math.atan2(dy, dx);
            const knobX = Math.cos(angle) * visualDist;
            const knobY = Math.sin(angle) * visualDist;
            
            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            if (distance > 5) {
                input.x = dx / distance;
                input.y = dy / distance;
            } else {
                input.x = 0;
                input.y = 0;
            }
        }
    }, { passive: false });

    window.addEventListener('touchend', e => {
        if (!state.isRunning) return;
        e.preventDefault();
        
        if (e.touches.length === 0) {
            input.active = false;
            input.x = 0;
            input.y = 0;
            input.shooting = false;
            joystickZone.style.display = 'none';
        } else if (e.touches.length === 1) {
            // Si on rel√¢che le doigt de tir mais qu'on garde le mouvement
            input.shooting = false;
            
            // Recalibrer si le doigt restant est celui du mouvement (index 0)
            const touch = e.touches[0];
            // On garde le joystick actif l√† o√π il est
        }
    });

    // Gestion des clics sur les boutons (Solution explicite pour iOS)
    document.getElementById('start-btn').addEventListener('click', startGame);
    // On ajoutera les √©couteurs pour les boutons g√©n√©r√©s dynamiquement (Restart) dans le HTML inject√©

    // Gestion PC
    window.addEventListener('mousemove', e => {
        if (!state.isRunning) return;
        if (!('ontouchstart' in window)) {
            if(player) {
                const angle = Math.atan2(e.clientY - player.y, e.clientX - player.x);
                const dist = Math.hypot(e.clientX - player.x, e.clientY - player.y);
                
                if (dist > 10) {
                    input.x = Math.cos(angle);
                    input.y = Math.sin(angle);
                } else {
                    input.x = 0;
                    input.y = 0;
                }
            }
        }
    });

    window.addEventListener('keydown', e => {
        if (e.code === 'Space') input.shooting = true;
    });
    window.addEventListener('keyup', e => {
        if (e.code === 'Space') input.shooting = false;
    });


    // --- CLASSES JEU (Player, Projectile, Enemy, Boss, PowerUp, Particle) ---
    // (Identiques √† la version pr√©c√©dente mais encapsul√©es)

    class Player {
        constructor() {
            this.x = width / 2;
            this.y = height / 2;
            this.size = 40;
            this.speed = 5;
            this.color = '#3498db';
            this.lives = 5;
            this.maxLives = 5;
            this.fireRate = 25;
            this.lastShot = 0;
            this.spreadShot = false;
            this.speedBoost = false;
        }

        update() {
            let dx = input.x;
            let dy = input.y;
            let currentSpeed = this.speedBoost ? this.speed * 1.5 : this.speed;

            this.x += dx * currentSpeed;
            this.y += dy * currentSpeed;
            this.x = Math.max(this.size, Math.min(width - this.size, this.x));
            this.y = Math.max(this.size, Math.min(height - this.size, this.y));
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.speedBoost) {
                ctx.beginPath();
                ctx.arc(0, 0, this.size/1.5, 0, Math.PI * 2);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (input.x < 0) ctx.scale(-1, 1);
            ctx.fillText('üßô‚Äç‚ôÇÔ∏è', 0, 0);
            ctx.restore();
        }

        shoot() {
            if (state.frames - this.lastShot < this.fireRate) return;
            let target = null;
            let minDist = Infinity;
            if (state.bossActive && boss) {
                const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                target = boss;
                minDist = dist;
            }
            enemies.forEach(e => {
                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist < minDist) {
                    minDist = dist;
                    target = e;
                }
            });
            let angle;
            if (target) {
                angle = Math.atan2(target.y - this.y, target.x - this.x);
            } else {
                if (input.x !== 0 || input.y !== 0) {
                    angle = Math.atan2(input.y, input.x);
                } else {
                    angle = -Math.PI / 2;
                }
            }
            projectiles.push(new Projectile(this.x, this.y, angle));
            if (this.spreadShot) {
                projectiles.push(new Projectile(this.x, this.y, angle - 0.3));
                projectiles.push(new Projectile(this.x, this.y, angle + 0.3));
            }
            this.lastShot = state.frames;
            createParticles(this.x, this.y, '#3498db', 3);
        }

        takeDamage() {
            this.lives--;
            updateHUD();
            screenShake(10);
            createParticles(this.x, this.y, '#e74c3c', 10);
            if (this.lives <= 0) endGame();
        }
    }

    class Projectile {
        constructor(x, y, angle, isEnemy = false) {
            this.x = x;
            this.y = y;
            this.radius = isEnemy ? 6 : 4;
            this.speed = isEnemy ? 6 : 10;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.color = isEnemy ? '#e74c3c' : '#f1c40f';
            this.isEnemy = isEnemy;
            this.markedForDeletion = false;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.markedForDeletion = true;
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.speed = levels[state.level].enemySpeed + (Math.random() * 0.5);
            this.hp = state.level;
            this.markedForDeletion = false;
            const types = ['üêç', 'üï∑Ô∏è', 'ü¶á'];
            this.emoji = types[(state.level - 1) % types.length];
        }
        update() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
        }
        draw() {
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x, this.y);
        }
    }

    class Boss {
        constructor() {
            this.x = width / 2;
            this.y = -100;
            this.targetY = 100;
            this.size = 80;
            this.maxHp = levels[state.level].bossHp;
            this.hp = this.maxHp;
            this.angle = 0;
            this.actionTimer = 0;
            const bosses = ['üêâ', 'ü¶ç', 'üë∫'];
            this.emoji = bosses[state.level - 1];
        }
        update() {
            if (this.y < this.targetY) { this.y += 2; return; }
            this.x += Math.sin(state.frames / 50) * 3;
            this.actionTimer++;
            if (this.actionTimer > 60) {
                this.attack();
                this.actionTimer = 0;
            }
        }
        attack() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            if (state.level === 1) {
                projectiles.push(new Projectile(this.x, this.y, angle, true));
            } else if (state.level === 2) {
                projectiles.push(new Projectile(this.x, this.y, angle, true));
                projectiles.push(new Projectile(this.x, this.y, angle - 0.3, true));
                projectiles.push(new Projectile(this.x, this.y, angle + 0.3, true));
            } else {
                for(let i=0; i<8; i++) {
                    projectiles.push(new Projectile(this.x, this.y, angle + (i * Math.PI/4), true));
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            const scale = 1 + Math.sin(state.frames / 20) * 0.1;
            ctx.scale(scale, scale);
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, 0, 0);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 20;
            this.markedForDeletion = false;
            const types = [
                { type: 'heal', emoji: '‚ù§Ô∏è', color: '#e74c3c' },
                { type: 'spread', emoji: '‚ö°', color: '#f1c40f' },
                { type: 'speed', emoji: 'üëü', color: '#3498db' }
            ];
            let rand = Math.random();
            if (player.lives <= 2 && rand < 0.5) {
                this.props = types[0];
            } else {
                this.props = types[Math.floor(Math.random() * types.length)];
            }
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y + Math.sin(state.frames/10)*5, 15, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.props.emoji, this.x, this.y + Math.sin(state.frames/10)*5);
        }
    }

    class Particle {
        constructor(x, y, color, speed) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 3 + 1;
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * speed;
            this.vx = Math.cos(angle) * velocity;
            this.vy = Math.sin(angle) * velocity;
            this.life = 1.0;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.02;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color, 2));
        }
    }

    // --- LOGIQUE JEU ---

    function spawnEnemy() {
        if (state.bossActive) return;
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -30 : width + 30;
            y = Math.random() * height;
        } else {
            x = Math.random() * width;
            y = Math.random() < 0.5 ? -30 : height + 30;
        }
        enemies.push(new Enemy(x, y));
    }

    function checkCollisions() {
        projectiles.forEach(p => {
            if (p.isEnemy) return;
            if (state.bossActive && boss) {
                const dist = Math.hypot(p.x - boss.x, p.y - boss.y);
                if (dist < boss.size/2 + p.radius) {
                    boss.hp -= 5;
                    p.markedForDeletion = true;
                    createParticles(p.x, p.y, '#fff', 5);
                    const percent = (boss.hp / boss.maxHp) * 100;
                    document.getElementById('boss-hp-bar').style.width = `${percent}%`;
                    if (boss.hp <= 0) levelComplete();
                }
            }
            enemies.forEach(e => {
                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if (dist < e.size/2 + p.radius) {
                    e.hp--;
                    p.markedForDeletion = true;
                    if (e.hp <= 0) {
                        e.markedForDeletion = true;
                        state.score += 10;
                        state.enemiesKilledInLevel++;
                        createParticles(e.x, e.y, '#2ecc71', 8);
                        if (Math.random() < 0.15) powerups.push(new PowerUp(e.x, e.y));
                        updateHUD();
                    } else {
                        createParticles(e.x, e.y, '#fff', 2);
                    }
                }
            });
        });

        enemies.forEach(e => {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < player.size/2 + e.size/2) {
                player.takeDamage();
                e.markedForDeletion = true;
            }
        });

        projectiles.forEach(p => {
            if (!p.isEnemy) return;
            const dist = Math.hypot(p.x - player.x, p.y - player.y);
            if (dist < player.size/2 + p.radius) {
                player.takeDamage();
                p.markedForDeletion = true;
            }
        });

        powerups.forEach(p => {
            const dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size/2 + p.size) {
                applyPowerUp(p.props.type);
                p.markedForDeletion = true;
            }
        });
    }

    function applyPowerUp(type) {
        const text = document.createElement('div');
        text.className = 'absolute text-yellow-300 font-bold text-xl animate-bounce';
        text.style.left = player.x + 'px';
        text.style.top = (player.y - 40) + 'px';
        text.innerText = type.toUpperCase() + "!";
        document.body.appendChild(text);
        setTimeout(() => text.remove(), 1000);

        if (type === 'heal') {
            player.lives = Math.min(player.lives + 1, player.maxLives);
            updateHUD();
        } else if (type === 'spread') {
            player.spreadShot = true;
            setTimeout(() => player.spreadShot = false, 8000);
        } else if (type === 'speed') {
            player.speedBoost = true;
            setTimeout(() => player.speedBoost = false, 8000);
        }
    }

    function checkLevelProgress() {
        if (!state.bossActive && state.enemiesKilledInLevel >= levels[state.level].killsToBoss) {
            spawnBoss();
        }
    }

    function spawnBoss() {
        state.bossActive = true;
        boss = new Boss();
        const bossContainer = document.getElementById('boss-hp-container');
        bossContainer.classList.remove('hidden');
        document.getElementById('boss-hp-bar').style.width = '100%';
        const alert = document.createElement('div');
        alert.innerText = "ATTENTION: " + levels[state.level].bossName + " !";
        alert.className = "absolute top-1/3 w-full text-center text-red-500 text-3xl font-bold blink";
        document.body.appendChild(alert);
        setTimeout(() => alert.remove(), 3000);
    }

    function levelComplete() {
        if (state.level >= 3) {
            winGame();
        } else {
            state.level++;
            state.enemiesKilledInLevel = 0;
            state.bossActive = false;
            boss = null;
            document.getElementById('boss-hp-container').classList.add('hidden');
            player.lives = 5;
            updateHUD();
            showOverlay(`
                <h2 class="text-3xl text-yellow-400 mb-4">Niveau Termin√© !</h2>
                <p>Pr√™t pour le niveau ${state.level} ?</p>
                <button class="btn" onclick="resumeGame()">Continuer</button>
            `);
            state.isRunning = false;
        }
    }

    let shakeDuration = 0;
    function screenShake(frames) {
        shakeDuration = frames;
    }

    function loop() {
        if (!state.isRunning) return;
        ctx.fillStyle = levels[state.level].color;
        ctx.fillRect(0, 0, width, height);

        if (shakeDuration > 0) {
            const dx = (Math.random() - 0.5) * 10;
            const dy = (Math.random() - 0.5) * 10;
            ctx.translate(dx, dy);
            shakeDuration--;
        }

        state.frames++;
        player.update();
        player.draw();
        if (input.shooting) player.shoot();
        if (!state.bossActive && state.frames % levels[state.level].spawnRate === 0) spawnEnemy();
        
        enemies.forEach((e, i) => { e.update(); e.draw(); if (e.markedForDeletion) enemies.splice(i, 1); });
        if (state.bossActive && boss) { boss.update(); boss.draw(); }
        projectiles.forEach((p, i) => { p.update(); p.draw(); if (p.markedForDeletion) projectiles.splice(i, 1); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });
        powerups.forEach((p, i) => { p.draw(); if (p.markedForDeletion) powerups.splice(i, 1); });

        checkCollisions();
        checkLevelProgress();

        if (shakeDuration >= 0) ctx.setTransform(1, 0, 0, 1, 0, 0); 
        requestAnimationFrame(loop);
    }

    function updateHUD() {
        document.getElementById('level-display').innerText = `Niveau: ${state.level}`;
        document.getElementById('score-display').innerText = `Score: ${state.score}`;
        let hearts = '';
        for(let i=0; i<player.lives; i++) hearts += '‚ù§Ô∏è';
        document.getElementById('lives-display').innerHTML = hearts;
    }

    // Gestion centralis√©e de l'Overlay pour √©viter les soucis d'event listener
    function showOverlay(htmlContent) {
        const overlay = document.getElementById('overlay');
        overlay.classList.remove('hidden');
        overlay.innerHTML = htmlContent;
    }

    function startGame() {
        console.log("Game Starting...");
        document.getElementById('overlay').classList.add('hidden');
        
        // Reset COMPLET
        player = new Player();
        enemies = [];
        projectiles = [];
        particles = [];
        powerups = [];
        boss = null;
        
        state.level = 1;
        state.score = 0;
        state.enemiesKilledInLevel = 0;
        state.lives = 5;
        state.isRunning = true;
        state.bossActive = false;
        
        input.active = false;
        input.shooting = false;
        
        updateHUD();
        document.getElementById('boss-hp-container').classList.add('hidden');
        
        loop();
    }

    // Exposer globalement pour le HTML inject√© dans l'overlay
    window.resumeGame = function() {
        document.getElementById('overlay').classList.add('hidden');
        state.isRunning = true;
        projectiles = [];
        loop();
    };

    window.startGame = startGame; // Explicite pour les onclick HTML

    function endGame() {
        state.isRunning = false;
        showOverlay(`
            <h1 class="text-red-500 text-4xl mb-4">GAME OVER</h1>
            <p class="text-xl mb-4">Score Final: ${state.score}</p>
            <button class="btn" onclick="startGame()">Recommencer</button>
        `);
    }

    function winGame() {
        state.isRunning = false;
        showOverlay(`
            <h1 class="text-yellow-400 text-4xl mb-4">VICTOIRE !</h1>
            <p class="mb-4">Tu as surv√©cu √† la jungle INABRA-KADRABRA !</p>
            <p class="text-xl mb-4">Score Final: ${state.score}</p>
            <button class="btn" onclick="startGame()">Rejouer</button>
        `);
    }

</script>
</body>
</html>
